<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>모바일용 웹캠 컬러 파티클 + 프랙탈 가지 효과 + 그래픽 이퀄라이저 인터랙션</title>
  <!-- HTTPS 환경에서 사용하세요. (모바일 getUserMedia는 HTTPS 필수) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval';">
  <style>
    body { 
      margin: 0; 
      background: #000; 
      overflow: hidden; 
    }
    canvas { display: block; }
    /* 모바일에서는 웹캠 video와 샘플링용 canvas는 보이지 않도록 함 */
    #videoElement, #videoCanvas { display: none; }
  </style>
</head>
<body>
  <!-- 웹캠 영상용 video 요소 -->
  <video id="videoElement" autoplay playsinline></video>
  <!-- 영상 샘플링용 offscreen canvas (낮은 해상도, 그리드 용) -->
  <canvas id="videoCanvas"></canvas>
  
  <!-- three.min.js 파일은 mobile.html과 같은 폴더에 위치 -->
  <script src="three.min.js"></script>
  <script>
    /***** 1. Three.js 기본 설정 *****/
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    camera.position.z = 100;
    camera.lookAt(scene.position);
    
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);
    
    /***** 2. 파티클(그리드) 생성 *****/
    var gridCols = 80;
    var gridRows = 60;
    var totalParticles = gridCols * gridRows;
    var spacing = 2;
    
    var basePositions = new Float32Array(totalParticles * 3);
    var positions = new Float32Array(totalParticles * 3);
    var colors = new Float32Array(totalParticles * 3);
    var angles = new Float32Array(totalParticles);
    
    var offsetX = (gridCols - 1) * spacing / 2;
    var offsetY = (gridRows - 1) * spacing / 2;
    
    for (var i = 0; i < gridRows; i++) {
      for (var j = 0; j < gridCols; j++) {
        var index = i * gridCols + j;
        var x = j * spacing - offsetX;
        var y = - (i * spacing - offsetY);
        var z = 0;
        basePositions[index * 3]     = x;
        basePositions[index * 3 + 1] = y;
        basePositions[index * 3 + 2] = z;
        positions[index * 3]     = x;
        positions[index * 3 + 1] = y;
        positions[index * 3 + 2] = z;
        colors[index * 3]     = 1;
        colors[index * 3 + 1] = 1;
        colors[index * 3 + 2] = 1;
        angles[index] = Math.random() * Math.PI * 2;
      }
    }
    
    var geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('angle', new THREE.BufferAttribute(angles, 1));
    
    /***** 3. 커스텀 쉐이더 재질 설정 *****/
    var uniforms = {
      uSize: { value: 18.0 },
      uBeatFactor: { value: 0.0 }
    };
    
    var shaderMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: `
        attribute float angle;
        varying float vAngle;
        varying vec3 vColor;
        uniform float uSize;
        void main() {
          vAngle = angle;
          vColor = color;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = uSize;
        }
      `,
      fragmentShader: `
        uniform float uBeatFactor;
        varying float vAngle;
        varying vec3 vColor;
        
        float fractalBranch(vec2 p) {
          float intensity = 0.0;
          for (int i = 0; i < 3; i++) {
            p = abs(p) - 0.15;
            intensity = max(intensity, 1.0 - length(p) * 2.0);
            p *= 1.8;
          }
          return intensity;
        }
        
        void main() {
          vec2 coord = gl_PointCoord;
          vec2 centered = coord - vec2(0.5);
          float baseAlpha = 0.0;
          float lineWidth = 0.2;
          vec2 rotated = vec2(
              centered.x * cos(vAngle) - centered.y * sin(vAngle),
              centered.x * sin(vAngle) + centered.y * cos(vAngle)
          ) + vec2(0.5);
          if (abs(rotated.x - 0.5) < lineWidth || abs(rotated.y - 0.5) < lineWidth) {
            baseAlpha = 1.0;
          }
          float branchAlpha = 0.0;
          if (uBeatFactor > 0.2) {
            branchAlpha = fractalBranch(gl_PointCoord - vec2(0.5));
          }
          float alpha = max(baseAlpha, branchAlpha);
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      vertexColors: true
    });
    
    var particles = new THREE.Points(geometry, shaderMaterial);
    scene.add(particles);
    
    /***** 4. 웹캠 영상 설정 *****/
    var video = document.getElementById('videoElement');
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(function(stream) {
          video.srcObject = stream;
          video.play();
        })
        .catch(function(err) {
          console.error("웹캠 접근 실패:", err);
        });
    }
    
    var videoCanvas = document.getElementById('videoCanvas');
    videoCanvas.width = gridCols;
    videoCanvas.height = gridRows;
    var videoCtx = videoCanvas.getContext('2d');
    
    /***** 5. 마이크 인풋 및 주파수 분석 설정 (Web Audio API) *****/
    var analyser, freqData;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true, video: false })
      .then(function(stream) {
        var audioContext = new (window.AudioContext || window.webkitAudioContext)();
        var source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        freqData = new Uint8Array(analyser.frequencyBinCount);
      })
      .catch(function(err) {
        console.error("마이크 접근 실패:", err);
      });
    }
    
    /***** 6. 모바일 화면에 맞춰 카메라 및 렌더러 조정 *****/
    // video의 메타데이터가 로드되면, 카메라의 aspect를 video 비율로 설정
    video.addEventListener('loadedmetadata', function() {
      var videoAspect = video.videoWidth / video.videoHeight;
      // 모바일 화면에 맞게 renderer 크기를 조정합니다.
      var newWidth = window.innerWidth;
      var newHeight = window.innerWidth / videoAspect;
      camera.aspect = videoAspect;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    });
    
    /***** 7. 애니메이션 루프 *****/
    var globalBeat = 0.0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      /***** (A) 웹캠 영상 샘플링 및 파티클 컬러 업데이트 *****/
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        videoCtx.drawImage(video, 0, 0, videoCanvas.width, videoCanvas.height);
        var imageData = videoCtx.getImageData(0, 0, videoCanvas.width, videoCanvas.height);
        var data = imageData.data;
        for (var i = 0; i < gridRows; i++) {
          for (var j = 0; j < gridCols; j++) {
            var index = i * gridCols + j;
            var pixelIndex = index * 4;
            colors[index * 3]     = data[pixelIndex] / 255;
            colors[index * 3 + 1] = data[pixelIndex + 1] / 255;
            colors[index * 3 + 2] = data[pixelIndex + 2] / 255;
          }
        }
        geometry.attributes.color.needsUpdate = true;
      }
      
      /***** (B) (모바일용) – 마우스 인터랙션 제거됨 *****/
      
      /***** (C) 마이크 주파수 분석 및 드럼/비트 기반 컬러 변화 효과 *****/
      if (analyser) {
        analyser.getByteFrequencyData(freqData);
        var lowSum = 0;
        for (var i = 0; i < 43; i++) { lowSum += freqData[i]; }
        var lowAvg = lowSum / 43 / 255;
        var newSize = 18 - 13.5 * lowAvg;
        if (newSize < 4.5) newSize = 4.5;
        uniforms.uSize.value = newSize;
        
        var angleArray = geometry.attributes.angle.array;
        var midSum = 0;
        for (var i = 43; i < 86; i++) { midSum += freqData[i]; }
        var midAvg = midSum / 43 / 255;
        for (var i = 0; i < totalParticles; i++){
          angleArray[i] += midAvg * 0.2;
          if (angleArray[i] > Math.PI * 2) {
            angleArray[i] -= Math.PI * 2;
          }
        }
        geometry.attributes.angle.needsUpdate = true;
        
        var beatSum = 0;
        for (var i = 0; i < 10; i++){
          beatSum += freqData[i];
        }
        var beatAvg = beatSum / 10 / 255;
        var newBeat = beatAvg * 0.5;
        if (newBeat > globalBeat) {
          globalBeat = newBeat;
        } else {
          globalBeat *= 0.5;
        }
        var beatFactor = Math.min(globalBeat, 1.0);
        uniforms.uBeatFactor.value = beatFactor;
        
        for (var i = 0; i < totalParticles; i++){
          var baseR = colors[i * 3];
          var baseG = colors[i * 3 + 1];
          var baseB = colors[i * 3 + 2];
          var baseColor = new THREE.Color(baseR, baseG, baseB);
          var hsl = { h: 0, s: 0, l: 0 };
          baseColor.getHSL(hsl);
          var compH = (hsl.h + 0.5) % 1.0;
          var complement = new THREE.Color();
          complement.setHSL(compH, 1.0, 0.5);
          var mixAmount = Math.min(beatFactor * 2.0, 1.0);
          baseColor.lerp(complement, mixAmount);
          colors[i * 3]   = baseColor.r;
          colors[i * 3 + 1] = baseColor.g;
          colors[i * 3 + 2] = baseColor.b;
        }
        geometry.attributes.color.needsUpdate = true;
      }
      
      /***** (D) 프랙탈 가지 효과: 소리(비트)에 반응할 때 각 파티클 내부에서 가지 효과 적용 *****/
      // 프래그먼트 쉐이더 내에서 uBeatFactor를 이용하여 처리되므로,
      // 여기서는 별도의 vertex 변환은 하지 않습니다.
      
      renderer.render(scene, camera);
    }
    animate();
    
    /***** (E) 창 크기 변경 대응 *****/
    window.addEventListener('resize', function(){
      // 모바일에서도 화면 크기에 맞춰 카메라와 렌더러 업데이트
      var newWidth = window.innerWidth;
      var newHeight = window.innerWidth / (video.videoWidth / video.videoHeight || (window.innerWidth/window.innerHeight));
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
    });
  </script>
</body>
</html>
